# include the file where we declare all the env variables
include /aegis/core/config/envs.conf;


worker_processes 1;
error_log /usr/local/openresty/nginx/logs/error.log;

events {
   worker_connections 1024;
   use epoll;
   multi_accept on;
}


http {
    lua_package_path "/usr/local/openresty/lualib/?.lua;/aegis/core/lib/?.lua;;";
    lua_shared_dict service_cache 10m;
    lua_shared_dict jwt_cache 10m;
    lua_shared_dict rbac_cache 10m;
    lua_shared_dict rate_limit_cache 10m;

    upstream dynamic_backends {
        # $backend_addr
        server 127.0.0.1:8080; # Fallback
    }

    upstream admin {
        # $admin_addr
        server 127.0.0.1:4567; # Sinatra app
    }

    server {
        listen 80;
        server_name *.example.com;

        set_by_lua $skip_paths 'return os.getenv("SKIP_PATHS")';
        set_by_lua $backend_addr 'return os.getenv("BACKEND_ADDR")'; # Fallback
        error_log /aegis/core/logs/error.log debug;
        location /metrics {
            content_by_lua_block {
                local prometheus = require "resty.prometheus"
                prometheus:render()
            }
        }
        location /admin/ {
            proxy_pass http://admin;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }
        location /docs {
            proxy_pass http://admin;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }
        location / {
            access_by_lua_file /aegis/core/lib/jwt_aegis.lua;
            header_filter_by_lua_block {
                local context = {
                    request = {
                        uri = ngx.var.uri,
                        method = ngx.var.request_method,
                        host = ngx.var.host,
                        headers = ngx.req.get_headers()
                    },
                    response = { headers = ngx.resp.get_headers() },
                    payload = ngx.ctx.payload,
                    backend_addr = ngx.var.backend_addr,
                    start_time = ngx.ctx.start_time,
                    cache_hit = ngx.ctx.cache_hit,
                    cache_type = ngx.ctx.cache_type,
                    rate_limit_exceeded = ngx.ctx.rate_limit_exceeded
                }
                require("plugin_loader").new():run_phase("header_filter", context)
            }
            body_filter_by_lua_block {
                local context = {
                    request = {
                        uri = ngx.var.uri,
                        method = ngx.var.request_method,
                        host = ngx.var.host,
                        headers = ngx.req.get_headers()
                    },
                    response = { headers = ngx.resp.get_headers(), body = ngx.arg[1] },
                    payload = ngx.ctx.payload,
                    backend_addr = ngx.var.backend_addr,
                    start_time = ngx.ctx.start_time,
                    cache_hit = ngx.ctx.cache_hit,
                    cache_type = ngx.ctx.cache_type,
                    rate_limit_exceeded = ngx.ctx.rate_limit_exceeded
                }
                require("plugin_loader").new():run_phase("body_filter", context)
                ngx.arg[1] = context.response.body or ngx.arg[1]
            }
            log_by_lua_block {
                local context = {
                    request = {
                        uri = ngx.var.uri,
                        method = ngx.var.request_method,
                        host = ngx.var.host,
                        headers = ngx.req.get_headers()
                    },
                    response = { headers = ngx.resp.get_headers(), status = ngx.status },
                    payload = ngx.ctx.payload,
                    backend_addr = ngx.var.backend_addr,
                    start_time = ngx.ctx.start_time,
                    cache_hit = ngx.ctx.cache_hit,
                    cache_type = ngx.ctx.cache_type,
                    rate_limit_exceeded = ngx.ctx.rate_limit_exceeded
                }
                require("plugin_loader").new():run_phase("log", context)
            }
            proxy_pass http://$backend_addr;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-User-Id $http_x_user_id;
            proxy_set_header X-Company-Group-Id $http_x_company_group_id;
        }
    }
}
